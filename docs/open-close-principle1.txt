 Open/Closed Principle (OCP)
The Open/Closed Principle states that a software entity (like a class or module) should be open for extension but closed for modification. This means that you should be able to add new functionality to a class without modifying its existing code.

In practice, this often means designing classes in a way that allows behavior to be extended through inheritance, interfaces, or other techniques (like dependency injection) rather than changing existing code. This makes the system more robust because changes to the behavior can happen without altering the existing, tested code.

Benefits of OCP:
Reduced Risk of Bugs: You don’t modify existing code, so there’s less chance of introducing errors in previously tested code.
Enhanced Flexibility: New functionality can be added with minimal changes to the existing structure.
Easier Code Maintenance: Modifications are isolated, which makes understanding and maintaining code easier.
Example of OCP:
Suppose you have a class that calculates different types of employee bonuses:

python
Copy code
class BonusCalculator:
    def calculate_bonus(self, employee_type, salary):
        if employee_type == "permanent":
            return salary * 0.1
        elif employee_type == "contract":
            return salary * 0.05
This violates OCP because adding a new type of employee requires modifying the calculate_bonus method.

To follow OCP, you could refactor this using subclasses:

python
Copy code
from abc import ABC, abstractmethod

class Employee(ABC):
    @abstractmethod
    def calculate_bonus(self):
        pass

class PermanentEmployee(Employee):
    def calculate_bonus(self, salary):
        return salary * 0.1

class ContractEmployee(Employee):
    def calculate_bonus(self, salary):
        return salary * 0.05
Now, adding a new type of employee bonus only requires creating a new subclass without modifying existing code.

Summary
Single Responsibility Principle: A class should have only one responsibility or reason to change.
Open/Closed Principle: A class should be open for extension but closed for modification, promoting the addition of new functionality without altering existing code.
Both principles support creating cleaner, more modular, and maintainable code.